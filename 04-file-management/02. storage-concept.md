# 🔄 Full Disk-to-Data Flow in Linux

```bash

Disk 
 └── Partition Table 
      └── Partition(s) 
           └── Filesystem 
                └── Inode 
                     └── Data Blocks
```

🧱 1. Disk

The physical storage medium (HDD, SSD, NVMe). Example: /dev/sda, /dev/nvme0n1

📋 2. Partition Table


A small area at the start of the disk that describes how the disk is divided.


Types of partition tables:
- MBR (Master Boot Record) – legacy, supports up to 4 primary partitions.
- GPT (GUID Partition Table) – modern, supports 128+ partitions, required for disks > 2 TB.
- Tools: fdisk, gdisk, parted, lsblk, blkid

🧩 3. Partition


A section of the disk defined in the partition table. Appears as a device in /dev, like /dev/sda1, /dev/sda2, etc.

Can be used as:
- Raw block storage
- Part of a LVM or RAID
- Mounted after formatting with a filesystem


🗂️ 4. Filesystem (Formatting)


Applied to a partition to define how files and directories are stored. Examples: ext4, xfs, btrfs, vfat, ntfs. Tools: mkfs.ext4, mkfs.xfs, etc.


🧾 5. Inodes


Created when the filesystem is built (e.g., during mkfs).

Each inode contains:

- Metadata (permissions, owner, timestamps)
- Pointers to actual data blocks
- But not the filename
- Filenames are stored in directory entries which point to inodes number

📦 6. Data Blocks

Actual file contents are stored here. When a file is accessed, Linux uses:

Directory → Inode → Data Block(s)


# Volumes

In Linux, the term "volume" typically refers to a storage area used for reading/writing data, which may include physical disks, partitions, or abstracted logical volumes. Here are the main types of volumes in Linux:

🔹 1. Physical Volumes (PVs)

- These are actual disk devices or disk partitions that can be used directly or as part of LVM.
  Examples: /dev/sda1, /dev/xvdf
- Can be mounted directly or used inside a Volume Group (VG) in LVM.


🔹 2. Partitions

A physical disk can be divided into partitions, each acting as a separate volume. Tools: fdisk, parted, gparted

Types of partitions:
- Primary(3 in mbr)
- Extended(1 in mbr)
- Logical(multiple in extended)
- GPT can have 128 partition


# File System


a filesystem refers to the way data is organized and stored on a storage device (like an SSD, HDD, USB, etc.). It defines how files and directories are named, stored, and accessed.

🔹 Types of Filesystems in Linux

1. Ext (Extended Filesystem) Family


- ext2: Old but still used in USB drives and boot partitions. No journaling.
- ext3: Adds journaling (faster recovery after crash).
- ext4: Most commonly used. Supports large files and volumes, journaling, backwards compatible with ext2/3.

2. XFS

- High-performance journaling filesystem.
- Ideal for large files and parallel I/O.
- Used by default in some Red Hat-based distributions.

3. Btrfs (B-tree FS)
Modern, advanced features like:

- Snapshots
- Checksumming for data integrity
- Built-in RAID
- Still under active development.

4. F2FS (Flash-Friendly FS)

- Designed for NAND flash memory like SSDs, eMMC, and SD cards.

5. VFAT/FAT32/exFAT

- Windows-compatible filesystems.
- Used for USB drives, memory cards.
- FAT32 has 4GB file size limit; exFAT overcomes that.

6. NTFS

- Native Windows filesystem.
- Linux can read/write NTFS via ntfs-3g.

🔹 Linux Virtual Filesystem (VFS)

Linux uses a Virtual Filesystem Layer to provide a common interface to all filesystems.
Applications don’t need to know which filesystem is underneath.

```bash

/
├── bin     → Essential user commands (ls, cp, mv)
├── boot    → Boot loader files (vmlinuz, grub/)
├── dev     → Device files (disks, tty, etc.)
├── etc     → System configuration (passwd, ssh/)
├── home    → User directories (/home/user)
├── lib     → Libraries for binaries in /bin and /sbin
├── media   → Mount point for external devices (USBs)
├── mnt     → Temporary mount point (manual)
├── opt     → Optional software packages
├── proc    → Virtual filesystem for process info
├── root    → Root user's home directory
├── run     → Runtime variable data
├── sbin    → System binaries (mount, shutdown)
├── srv     → Data for services (e.g., web servers)
├── sys     → Virtual FS for system info (sysfs)
├── tmp     → Temporary files (auto deleted)
├── usr     → User-installed applications and libraries
├── var     → Variable data (logs, mail, spool)


```

## Special Filesystem

```bash

| Filesystem  | Purpose                                                    |
| ----------- | ---------------------------------------------------------- |
| `proc`      | Virtual FS for process/kernel info (e.g., `/proc/cpuinfo`) |
| `sysfs`     | Exposes kernel device tree                                 |
| `tmpfs`     | RAM-backed temporary storage (e.g., `/run`, `/tmp`)        |
| `devtmpfs`  | Auto-created device nodes in `/dev`                        |
| `cgroupfs`  | Control groups filesystem                                  |
| `overlayfs` | Used in containers (Docker uses it)                        |

```

📘 What Is an Inode?

An inode is a data structure that stores metadata about a file — but not the filename. Each inode contains metadata about a file plus pointers to the file’s data blocks on disk. These pointers are crucial for locating file content.


📝 Note: The filename is stored separately in the directory entry, which maps the name to an inode number.

```bash

📦 What Does an Inode Store?

Field	          Description
File type	      Regular file, directory, symlink, etc.
Permissions	      Read, write, execute for owner/group/others
Owner info	      UID (user ID), GID (group ID)
Size	          In bytes
Timestamps	      ctime, mtime, atime
Link count	      Number of hard links pointing to this inode
Pointers	      To the actual data blocks on disk

```

```bash

ls -li file.txt    #View inode number of a file
stat file.txt      #Detailed metadata from inode
df -i              #Check inode usage on a filesystem

```

🧠 How Inodes Work


When you create a file, the filesystem allocates:
- An inode for the metadata
- One or more data blocks for the file content
- The inode has block pointers that point to those blocks
- Filesystems like ext4 use direct, indirect, double-indirect, triple-indirect block pointers to handle large files efficiently
- Even if you have free disk space, you can run out of inodes — especially when storing millions of small files.


Block size is the smallest unit of data that a filesystem reads or writes to disk. It is set during formatting and affects performance, space efficiency, and compatibility.
Default: Usually 4 KB (4096 bytes) for most Linux filesystems (like ext4, xfs). If the file size is 1KB it will still take 1 complete block, and if file size is 4.1KB it will use two complete block
to store data. So for large file, large block size can help with less read/write i/o.

```bash

Inode
├── Direct Pointers (0–11) ─────────▶ Data Blocks (if file is small)
├── Single Indirect Pointer ───────▶ Block with more data block pointers
├── Double Indirect Pointer ──────▶ Block of blocks of pointers
└── Triple Indirect Pointer ──────▶ Block of blocks of blocks of pointers


| Pointer Type        | Max Data Blocks it Can Address (with 4K block size) |
| ------------------- | --------------------------------------------------- |
| **Direct (12)**     | 12                                                  |
| **Single Indirect** | 1024 (1 block × 1024 pointers)                      |
| **Double Indirect** | 1024 × 1024 = 1,048,576                             |
| **Triple Indirect** | 1024³ = 1,073,741,824                               |

📂 Example Use Case:

Suppose you have a file that is:
4 KB: stored in 1st direct pointer.
48 KB: uses 12 direct blocks (12 × 4KB).
5 MB: uses 12 direct + 1024 indirect + some double-indirect blocks.

```








